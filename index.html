import React, { useMemo, useState } from "react";

/**
 * GIGAVERSE FISH ASSIST (Day 2 update pack)
 * ✅ 1) Withdraw warning logic
 * ✅ 2) Deck health + coverage warning
 * ✅ 3) “RISK: <reason>” content (instead of plain RISK)
 * ✅ + Fish logo in the left box before title
 *
 * Drop this file in your React app as App.tsx (Tailwind assumed).
 */

/* ----------------------------- Types ----------------------------- */

type FishType = "1x1" | "PLUS" | "X";
type SpellId =
  | "center_single"
  | "corners"
  | "top_row"
  | "mid_row"
  | "bot_row"
  | "left_col"
  | "mid_col"
  | "right_col"
  | "plus_spell"
  | "x_spell";

type Spell = {
  id: SpellId;
  name: string;
  manaCost: number;
  // tiles in 0..8 that are covered by the spell
  covers: number[];
  // catch gain if hit; catch loss if miss
  hitDelta: number;
  missDelta: number; // negative value
};

type Recommendation = {
  spell: Spell | null;
  bestNextTile: number | null;
  hitChance: number;
  ev: number;
  riskReasons: string[];
  coverageScore: number;
  fishTypeBelief: Record<FishType, number>;
  nextTileProb: number[]; // length 9
};

/* ----------------------------- Helpers ----------------------------- */

const clamp01 = (x: number) => Math.max(0, Math.min(1, x));

const tiles = Array.from({ length: 9 }, (_, i) => i);

function tileRow(t: number) {
  return Math.floor(t / 3);
}
function tileCol(t: number) {
  return t % 3;
}

function spellCoversFromName(id: SpellId): number[] {
  switch (id) {
    case "center_single":
      return [4];
    case "corners":
      return [0, 2, 6, 8];
    case "top_row":
      return [0, 1, 2];
    case "mid_row":
      return [3, 4, 5];
    case "bot_row":
      return [6, 7, 8];
    case "left_col":
      return [0, 3, 6];
    case "mid_col":
      return [1, 4, 7];
    case "right_col":
      return [2, 5, 8];
    case "plus_spell":
      return [1, 3, 4, 5, 7];
    case "x_spell":
      return [0, 2, 4, 6, 8];
    default:
      return [];
  }
}

/**
 * Very lightweight fish-type belief from movement “shape hints”.
 * - PLUS: orthogonal-only moves (no diagonals)
 * - X: diagonal-only moves
 * - 1x1: tends to “stay/nearby” (we approximate by smaller jumps)
 *
 * You can replace this with your real bayes/likelihood model.
 */
function inferFishTypeBelief(history: number[]): Record<FishType, number> {
  if (history.length < 2) return { "1x1": 1 / 3, PLUS: 1 / 3, X: 1 / 3 };

  let ortho = 0;
  let diag = 0;
  let small = 0;
  for (let i = 1; i < history.length; i++) {
    const a = history[i - 1];
    const b = history[i];
    const dr = Math.abs(tileRow(a) - tileRow(b));
    const dc = Math.abs(tileCol(a) - tileCol(b));
    const manhattan = dr + dc;
    if (manhattan === 1) ortho++;
    if (dr === 1 && dc === 1) diag++;
    if (manhattan <= 1) small++;
  }

  // simple scoring
  const plusScore = 1 + ortho;
  const xScore = 1 + diag;
  const oneScore = 1 + small;

  const sum = plusScore + xScore + oneScore;
  return { "1x1": oneScore / sum, PLUS: plusScore / sum, X: xScore / sum };
}

/**
 * Next-tile probabilities (placeholder).
 * Mixes:
 * - local neighborhood mass (for 1x1)
 * - orthogonal neighbors (for PLUS)
 * - diagonal neighbors (for X)
 */
function inferNextTileProb(
  current: number | null,
  belief: Record<FishType, number>
): number[] {
  // If no current tile, uniform
  if (current === null) return Array(9).fill(1 / 9);

  const r = tileRow(current);
  const c = tileCol(current);

  // neighborhood helper
  const add = (arr: number[], t: number, w: number) => {
    if (t < 0 || t > 8) return;
    arr[t] += w;
  };

  const probs = Array(9).fill(0);

  // 1x1: prefer same tile + 4-neighbors + (tiny) diagonals
  {
    const w = belief["1x1"];
    add(probs, current, 0.45 * w);
    // orthogonal
    const ortho = [
      [r - 1, c],
      [r + 1, c],
      [r, c - 1],
      [r, c + 1],
    ];
    ortho.forEach(([rr, cc]) => {
      if (rr >= 0 && rr < 3 && cc >= 0 && cc < 3) {
        add(probs, rr * 3 + cc, 0.12 * w);
      }
    });
    // diagonals small
    const diags = [
      [r - 1, c - 1],
      [r - 1, c + 1],
      [r + 1, c - 1],
      [r + 1, c + 1],
    ];
    diags.forEach(([rr, cc]) => {
      if (rr >= 0 && rr < 3 && cc >= 0 && cc < 3) {
        add(probs, rr * 3 + cc, 0.035 * w);
      }
    });
  }

  // PLUS: orthogonal-only (no stay)
  {
    const w = belief.PLUS;
    const ortho = [
      [r - 1, c],
      [r + 1, c],
      [r, c - 1],
      [r, c + 1],
    ];
    ortho.forEach(([rr, cc]) => {
      if (rr >= 0 && rr < 3 && cc >= 0 && cc < 3) {
        add(probs, rr * 3 + cc, 0.25 * w);
      }
    });
  }

  // X: diagonal-only (no stay)
  {
    const w = belief.X;
    const diags = [
      [r - 1, c - 1],
      [r - 1, c + 1],
      [r + 1, c - 1],
      [r + 1, c + 1],
    ];
    diags.forEach(([rr, cc]) => {
      if (rr >= 0 && rr < 3 && cc >= 0 && cc < 3) {
        add(probs, rr * 3 + cc, 0.25 * w);
      }
    });
  }

  // Normalize
  const s = probs.reduce((a, b) => a + b, 0);
  if (s <= 0) return Array(9).fill(1 / 9);
  return probs.map((p) => p / s);
}

/**
 * Coverage score = probability mass covered by your *available* spells (in hand & selected).
 * Values: 0..1
 */
function computeCoverageScore(nextProb: number[], spells: Spell[]): number {
  if (spells.length === 0) return 0;
  const covered = new Set<number>();
  spells.forEach((sp) => sp.covers.forEach((t) => covered.add(t)));
  let mass = 0;
  for (let i = 0; i < 9; i++) {
    if (covered.has(i)) mass += nextProb[i];
  }
  return clamp01(mass);
}

function computeHitChance(nextProb: number[], covers: number[]): number {
  let p = 0;
  for (const t of covers) p += nextProb[t] ?? 0;
  return clamp01(p);
}

/* ----------------------------- UI bits ----------------------------- */

function Chip({
  children,
  tone = "neutral",
}: {
  children: React.ReactNode;
  tone?: "neutral" | "good" | "warn" | "bad";
}) {
  const base =
    "inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs border";
  const tones: Record<string, string> = {
    neutral: "border-white/10 text-white/80 bg-white/5",
    good: "border-emerald-400/20 text-emerald-200 bg-emerald-500/10",
    warn: "border-amber-400/20 text-amber-200 bg-amber-500/10",
    bad: "border-rose-400/20 text-rose-200 bg-rose-500/10",
  };
  return <span className={`${base} ${tones[tone]}`}>{children}</span>;
}

function Panel({
  title,
  children,
}: {
  title: string;
  children: React.ReactNode;
}) {
  return (
    <div className="rounded-3xl border border-white/10 bg-white/5 shadow-[0_0_0_1px_rgba(0,0,0,0.2),0_20px_80px_rgba(0,0,0,0.35)]">
      <div className="px-6 pt-5 pb-3">
        <div className="text-[12px] tracking-[0.2em] text-cyan-200/90 font-semibold">
          {title}
        </div>
      </div>
      <div className="px-6 pb-6">{children}</div>
    </div>
  );
}

function TileGrid({
  selected,
  highlights,
  onClick,
  labelMode = "index",
}: {
  selected: number | null;
  highlights?: Set<number>;
  onClick?: (t: number) => void;
  labelMode?: "index" | "none";
}) {
  return (
    <div className="grid grid-cols-3 gap-4">
      {tiles.map((t) => {
        const isSel = selected === t;
        const isHi = highlights?.has(t) ?? false;
        return (
          <button
            key={t}
            onClick={() => onClick?.(t)}
            className={[
              "relative h-20 rounded-2xl border transition",
              "bg-gradient-to-b from-white/10 to-white/0",
              isSel
                ? "border-emerald-300/70 shadow-[0_0_0_1px_rgba(16,185,129,0.25),0_0_40px_rgba(16,185,129,0.15)]"
                : "border-white/10 hover:border-white/20",
              isHi && !isSel
                ? "border-cyan-300/40 shadow-[0_0_0_1px_rgba(34,211,238,0.12)]"
                : "",
            ].join(" ")}
          >
            {labelMode === "index" && (
              <span className="absolute top-3 left-3 text-xs text-white/50">
                {t}
              </span>
            )}
          </button>
        );
      })}
    </div>
  );
}

function FishLogo() {
  // simple inline SVG fish mark (cyan glow)
  return (
    <div className="h-12 w-12 rounded-2xl border border-cyan-300/25 bg-cyan-500/10 shadow-[0_0_40px_rgba(34,211,238,0.12)] grid place-items-center">
      <svg width="26" height="26" viewBox="0 0 24 24" fill="none">
        <path
          d="M14.5 7.5c2.5 0 5 1.5 7 4.5-2 3-4.5 4.5-7 4.5-2.2 0-4.1-1.2-5.6-3.5H6.2L4 19l.8-4.2L4 10l2.2 2h2.7c1.5-2.3 3.4-3.5 5.6-3.5Z"
          stroke="rgba(34,211,238,0.95)"
          strokeWidth="1.6"
          strokeLinejoin="round"
        />
        <circle
          cx="16.7"
          cy="11.2"
          r="1"
          fill="rgba(34,211,238,0.95)"
        />
      </svg>
    </div>
  );
}

/* ----------------------------- Main App ----------------------------- */

const ALL_SPELLS: Spell[] = [
  { id: "center_single", name: "Center (Single)", manaCost: 2, covers: spellCoversFromName("center_single"), hitDelta: 10, missDelta: -5 },
  { id: "corners", name: "Corners", manaCost: 3, covers: spellCoversFromName("corners"), hitDelta: 6, missDelta: -3 },
  { id: "top_row", name: "Top Row", manaCost: 3, covers: spellCoversFromName("top_row"), hitDelta: 5, missDelta: -3 },
  { id: "mid_row", name: "Mid Row", manaCost: 3, covers: spellCoversFromName("mid_row"), hitDelta: 5, missDelta: -3 },
  { id: "bot_row", name: "Bottom Row", manaCost: 3, covers: spellCoversFromName("bot_row"), hitDelta: 5, missDelta: -3 },
  { id: "left_col", name: "Left Col", manaCost: 3, covers: spellCoversFromName("left_col"), hitDelta: 5, missDelta: -3 },
  { id: "mid_col", name: "Mid Col", manaCost: 3, covers: spellCoversFromName("mid_col"), hitDelta: 5, missDelta: -3 },
  { id: "right_col", name: "Right Col", manaCost: 3, covers: spellCoversFromName("right_col"), hitDelta: 5, missDelta: -3 },
  { id: "plus_spell", name: "Plus Spell", manaCost: 4, covers: spellCoversFromName("plus_spell"), hitDelta: 5, missDelta: -3 },
  { id: "x_spell", name: "X Spell", manaCost: 4, covers: spellCoversFromName("x_spell"), hitDelta: 5, missDelta: -3 },
];

function formatPct(x: number) {
  return `${(x * 100).toFixed(1)}%`;
}

export default function App() {
  // top bar state
  const [mana, setMana] = useState(6);
  const [catchValue, setCatchValue] = useState(0);
  const [lvl10Plus, setLvl10Plus] = useState(true);

  // fish state
  const [history, setHistory] = useState<number[]>([]);
  const currentTile = history.length ? history[history.length - 1] : null;

  // deck/hand state
  const [deck, setDeck] = useState<SpellId[]>([
    "top_row",
    "mid_row",
    "bot_row",
    "left_col",
    "center_single",
  ]); // pretend these are your current drawn cards
  const [selectedInHand, setSelectedInHand] = useState<Set<SpellId>>(
    () => new Set(deck)
  );

  const cardsRemaining = deck.length;

  const belief = useMemo(() => inferFishTypeBelief(history), [history]);
  const nextProb = useMemo(
    () => inferNextTileProb(currentTile, belief),
    [currentTile, belief]
  );

  const selectedSpells = useMemo(() => {
    const ids = Array.from(selectedInHand);
    return ids
      .map((id) => ALL_SPELLS.find((s) => s.id === id))
      .filter(Boolean) as Spell[];
  }, [selectedInHand]);

  // coverage score (for Day 2 warning)
  const coverageScore = useMemo(
    () => computeCoverageScore(nextProb, selectedSpells),
    [nextProb, selectedSpells]
  );

  const recommendation: Recommendation = useMemo(() => {
    const fishTypeLocked = Math.max(belief["1x1"], belief.PLUS, belief.X) >= 0.9;

    // Choose best spell by EV with “safety” gating (don’t allow miss to drop catch <= 0)
    let best: Spell | null = null;
    let bestEV = -Infinity;
    let bestHit = 0;

    for (const sp of selectedSpells) {
      if (sp.manaCost > mana) continue;

      const hitChance = computeHitChance(nextProb, sp.covers);

      // Expected change to catch (simple)
      const ev = hitChance * sp.hitDelta + (1 - hitChance) * sp.missDelta;

      // Safety logic: reject spells that would drop catch to 0 or below if miss
      const missCatch = catchValue + sp.missDelta;
      const violatesSafety = missCatch <= 0;

      // You can tweak: if you want “allow risky” at low catch, remove this.
      if (violatesSafety) continue;

      if (ev > bestEV) {
        bestEV = ev;
        best = sp;
        bestHit = hitChance;
      }
    }

    // If all got rejected by safety, pick the best EV anyway (but mark as risky)
    if (!best) {
      for (const sp of selectedSpells) {
        if (sp.manaCost > mana) continue;
        const hitChance = computeHitChance(nextProb, sp.covers);
        const ev = hitChance * sp.hitDelta + (1 - hitChance) * sp.missDelta;
        if (ev > bestEV) {
          bestEV = ev;
          best = sp;
          bestHit = hitChance;
        }
      }
    }

    // Best next tile (highest probability)
    let bestNextTile: number | null = 0;
    let mx = -1;
    for (let i = 0; i < 9; i++) {
      if (nextProb[i] > mx) {
        mx = nextProb[i];
        bestNextTile = i;
      }
    }

    // Day 2: “RISK: reason” content
    const riskReasons: string[] = [];
    if (best) {
      const missPenaltyHigh = Math.abs(best.missDelta) >= 4; // tune threshold
      const lowHit = bestHit < 0.45;
      const deckWeak = cardsRemaining <= 1;
      const uncertain = !fishTypeLocked;

      if (lowHit) riskReasons.push("low hit chance");
      if (missPenaltyHigh) riskReasons.push("high miss penalty");
      if (uncertain) riskReasons.push("uncertainty (fish type not locked)");
      if (deckWeak) riskReasons.push("deck weak (1 card)");
    }

    return {
      spell: best,
      bestNextTile,
      hitChance: best ? bestHit : 0,
      ev: Number.isFinite(bestEV) ? bestEV : 0,
      riskReasons,
      coverageScore,
      fishTypeBelief: belief,
      nextTileProb: nextProb,
    };
  }, [belief, nextProb, selectedSpells, mana, catchValue, cardsRemaining, coverageScore]);

  // Day 2: Withdraw warning logic
  const withdrawWarning = useMemo(() => {
    const fishTypeLocked =
      Math.max(belief["1x1"], belief.PLUS, belief.X) >= 0.9;

    const bestHitChance = recommendation.hitChance;
    const bestEV = recommendation.ev;

    const missWouldKillOrZeroOut =
      recommendation.spell ? catchValue + recommendation.spell.missDelta <= 0 : false;

    const deckCritical = cardsRemaining <= 1;

    const triggers =
      deckCritical &&
      (bestHitChance < 0.45 ||
        missWouldKillOrZeroOut ||
        coverageScore < 0.45 ||
        bestEV <= 0 ||
        !fishTypeLocked);

    const reasons: string[] = [];
    if (!deckCritical) return { show: false, reasons: [] as string[] };

    if (bestHitChance < 0.45) reasons.push("Best available hit chance is low");
    if (missWouldKillOrZeroOut) reasons.push("A miss would drop Catch to 0 or below");
    if (coverageScore < 0.45) reasons.push("Deck coverage is weak vs likely tiles");
    if (bestEV <= 0) reasons.push("Expected value is not positive");
    if (!fishTypeLocked) reasons.push("Fish type is not locked yet");

    return { show: triggers, reasons };
  }, [belief, recommendation, cardsRemaining, catchValue, coverageScore]);

  // UI highlight set for next-move grid
  const nextMoveHighlights = useMemo(() => {
    // highlight top 3 probable tiles
    const indexed = nextProb.map((p, i) => ({ p, i }));
    indexed.sort((a, b) => b.p - a.p);
    return new Set(indexed.slice(0, 3).map((x) => x.i));
  }, [nextProb]);

  const castHighlights = useMemo(() => {
    const sp = recommendation.spell;
    return sp ? new Set(sp.covers) : new Set<number>();
  }, [recommendation.spell]);

  function handleTileClick(t: number) {
    setHistory((h) => [...h, t]);
  }

  function resetAll() {
    setHistory([]);
    setCatchValue(0);
    setMana(6);
    // keep deck/selected as is
  }

  function undo() {
    setHistory((h) => h.slice(0, -1));
  }

  function redraw() {
    // toy redraw: rotate the deck (replace with your real draw system)
    const next = [...deck];
    next.push(next.shift()!);
    setDeck(next);
    setSelectedInHand(new Set(next));
  }

  function toggleSpell(id: SpellId) {
    setSelectedInHand((prev) => {
      const nx = new Set(prev);
      if (nx.has(id)) nx.delete(id);
      else nx.add(id);
      return nx;
    });
  }

  const deckHealthTone =
    cardsRemaining >= 3 ? "good" : cardsRemaining === 2 ? "warn" : "bad";

  const coverageTone =
    coverageScore >= 0.7 ? "good" : coverageScore >= 0.45 ? "warn" : "bad";

  const mainRiskLabel =
    recommendation.riskReasons.length > 0
      ? `RISK: ${recommendation.riskReasons[0]}`
      : "RISK: none";

  return (
    <div className="min-h-screen bg-[#061018] text-white">
      <div className="mx-auto max-w-[1200px] px-6 py-8">
        {/* Header bar */}
        <div className="flex items-center justify-between rounded-3xl border border-cyan-300/15 bg-white/5 px-6 py-4 shadow-[0_0_60px_rgba(34,211,238,0.08)]">
          <div className="flex items-center gap-4">
            {/* Day 2: fish logo in the box */}
            <FishLogo />

            <div>
              <div className="text-lg font-semibold tracking-wide">
                GIGAVERSE FISH ASSIST
              </div>
              <div className="text-xs text-white/60">
                Local-only predictor • no login • no wallet
              </div>
            </div>
          </div>

          <div className="flex items-center gap-3">
            <Chip>
              Mana{" "}
              <span className="ml-1 rounded-full bg-white/10 px-2 py-0.5 text-white/90">
                {mana}
              </span>
            </Chip>
            <Chip>
              Catch{" "}
              <span className="ml-1 rounded-full bg-white/10 px-2 py-0.5 text-white/90">
                {catchValue}
              </span>
            </Chip>
            <Chip>
              Lvl 10+{" "}
              <input
                type="checkbox"
                className="ml-2 accent-cyan-400"
                checked={lvl10Plus}
                onChange={(e) => setLvl10Plus(e.target.checked)}
              />
            </Chip>

            <button
              className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
              onClick={undo}
            >
              Undo
            </button>
            <button
              className="rounded-2xl border border-rose-400/30 bg-rose-500/10 px-4 py-2 text-sm hover:border-rose-300/50"
              onClick={resetAll}
            >
              Reset
            </button>
          </div>
        </div>

        {/* Withdraw Warning (Day 2) */}
        {withdrawWarning.show && (
          <div className="mt-5 rounded-3xl border border-amber-400/25 bg-amber-500/10 p-5">
            <div className="flex items-start justify-between gap-4">
              <div>
                <div className="text-sm font-semibold text-amber-200">
                  ⚠️ Consider WITHDRAW — deck is critical ({cardsRemaining} card
                  left)
                </div>
                <ul className="mt-2 list-disc pl-5 text-xs text-white/75">
                  {withdrawWarning.reasons.slice(0, 4).map((r, idx) => (
                    <li key={idx}>{r}</li>
                  ))}
                </ul>
              </div>
              <div className="flex gap-2">
                <button
                  className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
                  onClick={redraw}
                >
                  Redraw
                </button>
                <button
                  className="rounded-2xl border border-amber-400/30 bg-amber-500/10 px-4 py-2 text-sm hover:border-amber-300/50"
                  onClick={() => {
                    // placeholder “withdraw”: just reset history + keep deck
                    setHistory([]);
                    setCatchValue(0);
                  }}
                >
                  Withdraw
                </button>
              </div>
            </div>
          </div>
        )}

        <div className="mt-6 grid grid-cols-1 gap-6 lg:grid-cols-2">
          {/* Fish position */}
          <Panel title="FISH POSITION">
            <TileGrid selected={currentTile} onClick={handleTileClick} />
            <div className="mt-4 flex flex-wrap items-center gap-3">
              <Chip tone="neutral">History: {history.join(" → ") || "—"}</Chip>

              {/* Day 2: Deck health + coverage warnings */}
              <Chip tone={deckHealthTone as any}>
                Deck:{" "}
                {cardsRemaining >= 3
                  ? "Strong"
                  : cardsRemaining === 2
                  ? "Weak"
                  : "Critical"}{" "}
                ({cardsRemaining})
              </Chip>

              <Chip tone={coverageTone as any}>
                Coverage: {(coverageScore * 100).toFixed(0)}%
              </Chip>
            </div>

            <div className="mt-4 text-xs leading-relaxed text-white/65">
              Click the fish’s current tile each turn (0–8). The tool infers fish
              type (1x1 / Plus / X) and recommends the best spell from your
              selected hand.
              <div className="mt-2">
                Safety logic: if a miss would drop Catch to 0 or below, that
                spell is rejected (unless everything is rejected).
              </div>
            </div>
          </Panel>

          {/* Detector + Prediction */}
          <Panel title="FISH TYPE DETECTOR">
            <div className="space-y-3">
              {(["1x1", "PLUS", "X"] as FishType[]).map((k) => {
                const v = recommendation.fishTypeBelief[k];
                return (
                  <div key={k} className="flex items-center gap-3">
                    <div className="w-12 text-xs text-white/75">{k}</div>
                    <div className="h-2 flex-1 rounded-full bg-white/10 overflow-hidden">
                      <div
                        className="h-full bg-cyan-300/70"
                        style={{ width: `${(v * 100).toFixed(1)}%` }}
                      />
                    </div>
                    <div className="w-14 text-right text-xs text-white/70">
                      {formatPct(v)}
                    </div>
                  </div>
                );
              })}
            </div>

            <div className="mt-6 text-[12px] tracking-[0.2em] text-cyan-200/90 font-semibold">
              NEXT MOVE PREDICTION
            </div>
            <div className="mt-3">
              <TileGrid
                selected={recommendation.bestNextTile}
                highlights={nextMoveHighlights}
                onClick={undefined}
              />
            </div>

            {/* CAST */}
            <div className="mt-6 rounded-3xl border border-white/10 bg-white/5 p-4">
              <div className="flex items-center justify-between gap-3">
                <div className="flex items-center gap-3">
                  <span className="text-xl">▶</span>
                  <div className="text-sm font-semibold">
                    CAST:{" "}
                    <span className="text-white/90">
                      {recommendation.spell?.name ?? "—"}
                    </span>
                  </div>

                  {/* Day 2: RISK reason content */}
                  <span className="ml-2 rounded-full border border-amber-400/25 bg-amber-500/10 px-3 py-1 text-[11px] text-amber-200">
                    {mainRiskLabel}
                  </span>
                </div>

                <div className="flex gap-2">
                  <Chip>Best next tile {recommendation.bestNextTile ?? "—"}</Chip>
                  <Chip>Mana {mana}</Chip>
                  <Chip>Catch {catchValue}</Chip>
                </div>
              </div>

              <div className="mt-4 grid grid-cols-1 gap-3 md:grid-cols-2">
                <div className="rounded-2xl border border-white/10 bg-black/20 p-3">
                  <div className="text-xs text-white/70">
                    Hit chance:{" "}
                    <span className="text-cyan-200 font-semibold">
                      {formatPct(recommendation.hitChance)}
                    </span>
                    {"  "}•{"  "}
                    EV:{" "}
                    <span className="text-cyan-200 font-semibold">
                      {recommendation.ev.toFixed(2)}
                    </span>
                  </div>
                  <div className="mt-2 text-xs text-white/60">
                    If HIT → Catch becomes{" "}
                    <span className="text-white/85">
                      {recommendation.spell
                        ? catchValue + recommendation.spell.hitDelta
                        : catchValue}
                    </span>
                    . If MISS → Catch becomes{" "}
                    <span className="text-rose-200">
                      {recommendation.spell
                        ? catchValue + recommendation.spell.missDelta
                        : catchValue}
                    </span>
                    .
                  </div>

                  {/* show extra risk reasons */}
                  {recommendation.riskReasons.length > 1 && (
                    <div className="mt-2 text-[11px] text-white/55">
                      More: {recommendation.riskReasons.slice(1).join(" • ")}
                    </div>
                  )}
                </div>

                <div className="rounded-2xl border border-white/10 bg-black/20 p-3">
                  <div className="text-xs text-white/70 font-semibold">
                    Spell coverage preview
                  </div>
                  <div className="mt-2">
                    <TileGrid
                      selected={null}
                      highlights={castHighlights}
                      labelMode="none"
                    />
                  </div>
                </div>
              </div>
            </div>
          </Panel>
        </div>

        {/* Your spells */}
        <div className="mt-6 rounded-3xl border border-white/10 bg-white/5 px-6 py-6">
          <div className="text-[12px] tracking-[0.2em] text-cyan-200/90 font-semibold">
            YOUR SPELLS
          </div>
          <div className="mt-2 text-xs text-white/60">
            Toggle spells in your hand. The engine selects the spell with best
            expected value (EV) under safety + mana.
          </div>

          <div className="mt-5 flex flex-wrap gap-3">
            {deck.map((id) => {
              const sp = ALL_SPELLS.find((s) => s.id === id)!;
              const selected = selectedInHand.has(id);
              const afford = sp.manaCost <= mana;
              return (
                <button
                  key={id}
                  onClick={() => toggleSpell(id)}
                  className={[
                    "rounded-2xl border px-4 py-3 text-left transition min-w-[200px]",
                    selected
                      ? "border-cyan-300/40 bg-cyan-500/10"
                      : "border-white/10 bg-white/5 hover:border-white/20",
                    !afford ? "opacity-60" : "",
                  ].join(" ")}
                >
                  <div className="flex items-center justify-between gap-3">
                    <div className="text-sm font-semibold">{sp.name}</div>
                    <Chip tone={afford ? "neutral" : "warn"}>{sp.manaCost} mana</Chip>
                  </div>
                  <div className="mt-2 text-xs text-white/60">
                    Covers: {sp.covers.join(", ")}
                  </div>
                  <div className="mt-1 text-xs text-white/55">
                    Hit +{sp.hitDelta} • Miss {sp.missDelta}
                  </div>
                </button>
              );
            })}
          </div>

          <div className="mt-5 flex flex-wrap gap-3">
            <button
              className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
              onClick={() => setMana((m) => Math.max(0, m - 1))}
            >
              - Mana
            </button>
            <button
              className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
              onClick={() => setMana((m) => m + 1)}
            >
              + Mana
            </button>
            <button
              className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
              onClick={() => setCatchValue((c) => c + 1)}
            >
              + Catch
            </button>
            <button
              className="rounded-2xl border border-white/10 bg-white/5 px-4 py-2 text-sm hover:border-white/20"
              onClick={() => setCatchValue((c) => Math.max(0, c - 1))}
            >
              - Catch
            </button>

            <button
              className="ml-auto rounded-2xl border border-amber-400/25 bg-amber-500/10 px-4 py-2 text-sm hover:border-amber-300/50"
              onClick={redraw}
            >
              Redraw (toy)
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
